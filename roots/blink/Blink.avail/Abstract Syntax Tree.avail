/*
 * Abstract Syntax Tree.avail
 * Copyright (c) Todd L Smith and Taylor DH Smith, 2017.
 * All rights reserved.
 */

Module "Abstract Syntax Tree"
Uses
	"Avail" = ("variable" → "Avail variable", …),
	"Dimensional Analysis" = ("__", "ms"),
	"Events"
Names
	/* Abstract expressions. */
	"abstract expression",
		"expression type",
			"_'s⁇expression type",
	"_'s⁇subexpressions",
	"_expression",

	/* Abstract statements. */
	"abstract statement",
		"statement scope",
			"_'s⁇scope",
	"_statement",

	/* Literals. */
	"literal",
		"_'s⁇value",
	"_literal",

	/* Variables. */
	"variable",
		"variable name",
			"_'s⁇name",
		"variable scope",
			/*"_'s⁇scope",*/
		"variable mutability",
			"_'s⁇mutability",
	"scope",
		"local",
		"global",
	"mutability",
		"immutable",
		"mutable",
	"___variable",
	"__variable",
	"_variable",
	
	/* Signals. */
	"signal",
		"signal name",
			/*"_'s⁇name",*/

	/* Timers. */
	"timer",
		"timer name",
			/*"_'s⁇name",*/

	/* Variable declaration statements. */
	"variable declaration statement",
		"declared variable",
			"_'s⁇variable",

	/* Signal declaration statements. */
	"signal declaration statement",
		"declared signal",
			"_'s⁇signal",

	/* Timer declaration statements. */
	"timer declaration statement",
		"declared timer",
			"_'s⁇timer",

	/* State enumeration statements. */
	"state enumeration statement",
		"declared states",
			"_'s⁇states",

	/* Handler statements. */
	"event handler statement",
		"handled event",
			"_'s⁇event",
		"handler block",
			"_'s⁇block",
	"state changed event handler statement",
		"previous state",
			"_'s⁇previous state",
		"next state",
			"_'s⁇next state",
		/*"handler block",*/
			/*"_'s⁇block",*/
	"neighborhood state changed event handler statement",
		/*"previous state",*/
			/*"_'s⁇previous state",*/
		/*"next state",*/
			/*"_'s⁇next state",*/
		/*"handler block",*/
			/*"_'s⁇block",*/
	"timer threshold event handler statement",
		"handled timer",
			/*"_'s⁇timer",*/
		"declared timer threshold",
			"_'s⁇threshold",
	"timer expired event handler statement",
		/*"handled timer",*/
			/*"_'s⁇timer",*/
		/*"handler block",*/
			/*"_'s⁇block",*/
	"signal handler statement",
		"handled signal",
			/*"_'s⁇signal",*/
		/*"handler block",*/
			/*"_'s⁇block",*/

	/* Assignment statements. */
	"assignment statement",
		"assignment assignee",
			"_'s⁇assignee",
		"assignment value",
			/*"_'s⁇value",*/

	/* Block expressions. */
	"block expression",
		"block body",
			"_'s⁇body",

	/* Conditional expressions. */
	"conditional statement",
		"conditional predicate",
			"_'s⁇predicate",
		"positive block",
			"_'s⁇positive block",
	"conditional expression",
		/*"conditional predicate",*/
			/*"_'s⁇predicate",*/
		/*"positive block",*/
			/*"_'s⁇positive block",*/
		"negative block",
			"_'s⁇negative block",

	/* Operator expressions. */
	"operator expression",
		"expression operator",
			"_'s⁇operator",
		"expression operands",
			"_'s⁇operands",
	"_'s⁇arity",

	/* Signal expressions. */
	"fire signal statement",
		"fired signal",
			/*"_'s⁇signal",*/

	/* Timer expressions. */
	"timer query expression",
		"target timer",
			/*"_'s⁇timer",*/
	"timer set statement",
		/*"target timer",*/
			/*"_'s⁇timer",*/
		"timer value",
			/*"_'s⁇value",*/
	"timer update statement",
		/*"target timer",*/
			/*"_'s⁇timer",*/
		/*"timer value",*/
			/*"_'s⁇value",*/

	/* Programs. */
	"program",
	"program accumulator",
	"statement recorder for_"
Entries
	"*Dump program"
Body

/*
 * 2017.05.24 — The AST is kept minimal, to satisfy the prototype simulator and
 * its lone game, "Mortals". Only those features necessary to support "Mortals"
 * have been built.
 */

/******************************************************************************
 *                           Abstract expressions.                            *
 ******************************************************************************/

Public "expression type" is a new field atom;

/**
 * An {@type "abstract expression"} represents any Blink expression. It is
 * parametric on the static {@type "type"} of the Blink expression.
 *
 * @type "abstract expression"
 * @supertype "object"
 * @field "expression type" "⊤'s type"
 *        The static {@type "type"} of the {@type "abstract expression"
 *        expression}.
 * @field "statement scope" "scope"
 *        The {@type "scope"} of the {@type "abstract expression" expression}.
 */
Public class "abstract expression" extends object
	with field
		public expression type : ⊤'s type;

/**
 * Construct a {@type "abstract expression" Blink expression} {@type "type"} for
 * the specified {@type "type"}.
 *
 * @method "_expression"
 * @param "exprType" "⊤'s type"
 * @returns "abstract expression's type"
 */
Public method "_expression" is
[
	exprType : ⊤'s type
|
	extend abstract expression with expression type : (exprType's type)
];

/**
 * Strengthen the {@type "abstract expression" Blink expression} {@type "type"}
 * at compile time.
 *
 * @method "_expression"
 * @restricts "⊤'s type's type"
 */
Semantic restriction "_expression" is
[
	exprMeta : ⊤'s type's type
|
	(extend abstract expression with
		expression type : exprMeta)'s type
];

/**
 * Answer the {@type "abstract expression" subexpressions} of the specified
 * {@type "abstract expression" expression}.
 *
 * @method "_'s⁇subexpressions"
 * @param "expr" "abstract expression"
 * @returns "abstract expression*"
 */
Public abstract method "_'s⁇subexpressions" is
	[abstract expression]→abstract expression*;

/******************************************************************************
 *                                   Scope.                                   *
 ******************************************************************************/

/**
 * Answer an {@type "atom"} that denotes local scope.
 *
 * @method "local"
 * @returns "atom"
 */
Public "local" is a new atom;

/**
 * Answer an {@type "atom"} that denotes global scope.
 *
 * @method "global"
 * @returns "atom"
 */
Public "global" is a new atom;

/**
 * A {@type "scope"} denotes the scope of a {@type "variable"}, either {@method
 * "local"} or {@method "global"}.
 *
 * @type "scope"
 * @alias "{local, global}ᵀ"
 */
Public macro "scope" is [‘{local, global}ᵀ’];

/******************************************************************************
 *                            Abstract statements.                            *
 ******************************************************************************/

Public "statement scope" is a new field atom;

/**
 * An {@type "abstract statement"} represents any Blink statement. It is always
 * {@type "⊤"}-valued.
 *
 * @type "abstract statement"
 * @supertype "abstract expression"
 * @field "statement scope" "scope"
 *        The {@type "scope"} of the {@type "abstract expression" expression}.
 */
Public class "abstract statement" extends abstract expression
	with field
		public statement scope : scope ("_'s⁇scope");

/**
 * Construct a {@type "abstract statement" Blink statement} {@type "type"} for
 * the specified {@type "scope"}.
 *
 * @method "_statement"
 * @param "sc" "scope"
 * @returns "abstract statement's type"
 */
Public method "_statement" is
[
	sc : scope
|
	extend abstract statement with statement scope : (sc's type)
];

/**
 * Strengthen the {@type "abstract statement" Blink statement} {@type "type"}
 * at compile time.
 *
 * @method "_statement"
 * @restricts "scope's type"
 */
Semantic restriction "_statement" is
[
	scType : scope's type
|
	(extend abstract statement with statement scope : scType)'s type
];

/******************************************************************************
 *                                 Literals.                                  *
 ******************************************************************************/

/**
 * A {@type "literal"} denotes a statically known value. The {@field
 * "expression type"} of a {@type "literal"} must be an instance {@type
 * "any's type" type}.
 *
 * @type "literal"
 * @supertype "abstract expression"
 * @field "expression type" "any's type"
 */
Public explicit class "literal" extends abstract expression
	with field
		public expression type : any's type;

/**
 * Answer the {@type "any" value} that the specified {@type "literal"} denotes.
 *
 * @method "_'s⁇value"
 * @param "lit" "literal"
 * @returns "any"
 */
Public method "_'s⁇value" is
[
	lit : literal
|
	lit's expression type's instance
];

/**
 * Strengthen the {@type "literal"}'s {@type "_'s⁇value" value} {@type "type"}
 * at compile time.
 *
 * @method "_'s⁇value"
 * @restricts "literal's type"
 */
Semantic restriction "_'s⁇value" is
[
	litType : literal's type
|
	litType's expression type's instance
];

/**
 * Construct a {@type "literal"} {@type "type"} for the specified {@type
 * "type"}.
 *
 * @method "_literal"
 * @param "valueType" "any's type"
 * @returns "literal's type"
 */
Public method "_literal" is
[
	valueType : any's type
|
	extend literal with expression type : (valueType's type)
];

/**
 * Strengthen the {@type "literal"} {@type "type"} at compile time.
 *
 * @method "_literal"
 * @restricts "any's type's type"
 */
Semantic restriction "_literal" is
[
	exprMeta : any's type's type
|
	(extend literal with expression type : exprMeta)'s type
];

Public method "_'s⁇subexpressions" is [lit : literal| <>];

/******************************************************************************
 *                                 Variables.                                 *
 ******************************************************************************/

/**
 * Answer an {@type "atom"} that denotes immutability.
 *
 * @method "immutable"
 * @return "atom"
 */
Public "immutable" is a new atom;

/**
 * Answer an {@type "atom"} that denotes mutability.
 *
 * @method "mutable"
 * @return "atom"
 */
Public "mutable" is a new atom;

/**
 * A {@type "mutability"} denotes the mutability of a {@type "variable"}, either
 * {@method "immutable"} or {@method "mutable"}.
 *
 * @type "mutability"
 * @alias "{immutable, mutable}ᵀ"
 */
Public macro "mutability" is [‘{immutable, mutable}ᵀ’];

"variable name" is a new field atom;
"variable scope" is a new field atom;
"variable mutability" is a new field atom;

/**
 * A {@type "variable"} represents a statically typed fundamental storage unit
 * in a Blink program.
 *
 * @type "variable"
 * @supertype "abstract expression"
 * @param "variable name" "nonempty string"
 *        The lexical name of the {@type "variable"}.
 * @param "expression type" "any's type"
 * @param "variable scope" "scope"
 *        The {@type "scope"} of the {@type "variable"}, either {@method
 *        "local"} or {@type "global"}.
 * @param "variable mutability" "mutability"
 *        The mutability of a {@type "variable"}, either {@method "immutable"} or
 *        {@method "mutable"}.
 */
Public class "variable" extends abstract expression
	with fields
		public variable name : nonempty string ("_'s⁇name"),
		public expression type : any's type,
		public variable scope : scope ("_'s⁇scope"),
		public variable mutability : mutability ("_'s⁇mutability");

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type}, {@type "scope"}, and {@type "mutability"}.
 *
 * @method "___variable"
 * @param "varType" "any's type"
 * @param "scopeType" "scope"
 * @param "mutabilityType" "mutability"
 * @returns "variable's type"
 */
Public method "___variable" is
[
	varType : any's type,
	scopeType : scope,
	mutabilityType : mutability
|
	extend variable with
		expression type : (varType's type),
		variable scope : (scopeType's type),
		variable mutability : (mutabilityType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "___variable"
 * @restricts "any's type's type"
 * @restricts "scope's type"
 * @restricts "mutability's type"
 */
Semantic restriction "___variable" is
[
	varMeta : any's type's type,
	scopeMeta : scope's type,
	mutabilityMeta : mutability's type
|
	(extend variable with
		expression type : varMeta,
		variable scope : scopeMeta,
		variable mutability : mutabilityMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type} and {@type "scope"}.
 *
 * @method "__variable"
 * @param "varType" "any's type"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "__variable" is
[
	varType : any's type,
	scopeType : scope
|
	extend variable with
		expression type : (varType's type),
		variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "__variable"
 * @restricts "any's type's type"
 * @restricts "scope's type"
 */
Semantic restriction "__variable" is
[
	varMeta : any's type's type,
	scopeMeta : scope's type
|
	(extend variable with
		expression type : varMeta,
		variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "mutability"}.
 *
 * @method "_variable"
 * @param "mutabilityType" "mutability"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	mutabilityType : mutability
|
	extend variable with variable mutability : (mutabilityType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "mutability's type"
 */
Semantic restriction "_variable" is
[
	mutabilityMeta : mutability's type
|
	(extend variable with variable mutability : mutabilityMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "scope"}.
 *
 * @method "_variable"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	scopeType : scope
|
	extend variable with variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "scope's type"
 */
Semantic restriction "_variable" is
[
	scopeMeta : scope's type
|
	(extend variable with variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type}.
 *
 * @method "_variable"
 * @param "varType" "any's type"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	varType : any's type
|
	extend variable with expression type : (varType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "any's type's type"
 */
Semantic restriction "_variable" is
[
	varMeta : any's type's type
|
	(extend variable with expression type : varMeta)'s type
];

Public method "_'s⁇subexpressions" is [var : variable | <>];

/******************************************************************************
 *                                  Signals.                                  *
 ******************************************************************************/

Public "signal name" is a new field atom;

/**
 * A {@type "signal"} is a user-defined event.
 *
 * @type "signal"
 * @supertype "abstract expression"
 * @field "signal name" "nonempty string"
 *        The name of the {@type "signal"}.
 */
Public class "signal" extends abstract expression
	with field
		public signal name : nonempty string ("_'s⁇name");

Public method "_'s⁇subexpressions" is [sig : signal | <>];


/******************************************************************************
 *                                 Timers.                                    *
 ******************************************************************************/

Public "timer name" is a new field atom;

/**
 * A {@type "timer"} is a user-defined timer.
 *
 * @type "timer"
 * @supertype "abstract expression"
 * @field "timer name" "nonempty string"
 *        The name of the {@type "timer"}.
 */
Public class "timer" extends abstract expression
	with field
		public timer name : nonempty string ("_'s⁇name");

Public method "_'s⁇subexpressions" is [t : timer | <>];

/******************************************************************************
 *                      Variable declaration statements.                      *
 ******************************************************************************/

Public "declared variable" is a new field atom;

/**
 * A {@type "variable declaration statement"} declares a {@type "variable"}.
 *
 * @type "variable declaration statement"
 * @supertype "abstract statement"
 * @field "declared variable" "variable"
 *        The {@type "variable"} declared by the {@type
 *        "variable declaration statement"}.
 */
Public class "variable declaration statement" extends abstract statement
 	with field
 		public declared variable : variable ("_'s⁇variable");

Public method "_'s⁇subexpressions" is
	[stmt : variable declaration statement | <>];

Method "“_”" is
[
	stmt : variable declaration statement
|
	try
	[
		var ::= stmt's variable;
		format "‘①’ ‘②’ ‘③’ (‘④’ : “⑤”)" with
			(a|an) “var's mutability's name”,
			var's scope's name,
			stmt's type's names→tuple[1],
			stmt's variable's name,
			stmt's variable's expression type
	]
	else [“(stmt :: any)”]
];

/******************************************************************************
 *                       Signal declaration statements.                       *
 ******************************************************************************/

Public "declared signal" is a new field atom;

/**
 * A {@type "signal declaration statement"} declares a {@type "signal"}.
 *
 * @type "signal declaration statement"
 * @supertype "abstract statement"
 * @field "declared signal" "signal"
 *        The {@type "signal"} declared by the {@type
 *        "signal declaration statement"}.
 * @field "statement scope" "global's type"
 *        A {@type "signal declaration statement"} is always {@type "global"}.
 */
Public class "signal declaration statement" extends abstract statement
	with field
		public declared signal : signal ("_'s⁇signal"),
		public statement scope : global's type ("_'s⁇scope");

Public method "_'s⁇subexpressions" is
	[stmt : signal declaration statement | <>];

Method "“_”" is
[
	stmt : signal declaration statement
|
	try
	[
		sig ::= stmt's signal;
		format "‘①’ (‘②’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's signal's name
	]
	else [“(stmt :: any)”]
];

/******************************************************************************
 *                       Timer declaration statements.                        *
 ******************************************************************************/

Public "declared timer" is a new field atom;

/**
 * A {@type "timer declaration statement"} declares a {@type "timer"}.
 *
 * @type "timer declaration statement"
 * @supertype "abstract statement"
 * @field "declared timer" "timer"
 *        The {@type "timer"} declared by the {@type
 *        "timer declaration statement"}.
 * @field "statement scope" "global's type"
 *        A {@type "timer declaration statement"} is always {@type "global"}.
 */
Public class "timer declaration statement" extends abstract statement
	with field
		public declared timer : timer ("_'s⁇timer"),
		public statement scope : global's type ("_'s⁇scope");

Public method "_'s⁇subexpressions" is [stmt : timer declaration statement | <>];

Method "“_”" is
[
	stmt : timer declaration statement
|
	try
	[
		t ::= stmt's timer;
		format "‘①’ (‘②’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's timer's name
	]
	else [“(stmt :: any)”]
];

/******************************************************************************
 *                       State enumeration statements.                        *
 ******************************************************************************/

Public "declared states" is a new field atom;

/**
 * A {@type "state enumeration statement"} establishes the publicly available
 * Blink states. These are transmitted via IR. There must not be more than one
 * of these per program.
 *
 * @type "state enumeration statement"
 * @supertype "abstract statement"
 * @field "declared states" "atom*"
 *        All declared states. These are the only valid states for a particular
 *        program.
 * @field "statement scope" "global's type"
 *        A {@type "state enumeration statement"} is always {@type "global"}.
 */
Public class "state enumeration statement" extends abstract statement
	with fields
		public declared states : atom* ("_'s⁇states"),
		public statement scope : global's type ("_'s⁇scope");

Public method "_'s⁇subexpressions" is [stmt : state enumeration statement | <>];

Method "“_”" is
[
	stmt : state enumeration statement
|
	try
	[
		format "‘①’ (‘②’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			“map each x of stmt's states through [x's name]” (as simple list)
	]
	else [“(stmt :: any)”]
];

/******************************************************************************
 *                             Block expressions.                             *
 ******************************************************************************/

Public "block body" is a new field atom;

/**
 * A {@type "block expression"} represents a sequence of {@type
 * "abstract statements"} that reside in their own scope.
 *
 * @type "block expression"
 * @supertype "abstract expression"
 * @field "block body" "abstract expression*"
 *        The {@type "abstract statement" statements} that comprise the {@type
 *        "block expression"}.
 */
Public class "block expression" extends abstract expression
	with field
		public block body : abstract expression* ("_'s⁇body");

Public method "_'s⁇subexpressions" is [expr : block expression | expr's body];

/******************************************************************************
 *                         Event handler statements.                          *
 ******************************************************************************/

Public "handled event" is a new field atom;
Public "handler block" is a new field atom;

/**
 * An {@type "event handler statement"} establishes that a particular {@type
 * "event"} will execute a specific {@type "block expression" block of code}.
 *
 * @type "event handler statement"
 * @supertype "abstract statement"
 * @field "statement scope" "global's type"
 *        An {@type "event handler statement"} is always {@type "global"}.
 * @field "handled event" "event"
 *        The {@type "event"} handled by the {@type "event handler statement"}.
 * @field "handler block" "block expression"
 *        The {@type "block expression" block of code} that implements the logic
 *        of the {@type "event handler statement"}.
 */
Public class "event handler statement" extends abstract statement
	with field
		public statement scope : global's type ("_'s⁇scope"),
		public handled event : event ("_'s⁇event"),
		public handler block : block expression ("_'s⁇block");

Public method "_'s⁇subexpressions" is
	[expr : event handler statement | <>];

Method "“_”" is
[
	stmt : event handler statement
|
	try
	[
		format "‘①’ (‘②’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's event's name
	]
	else [“(stmt :: any)”]
];

Public "previous state" is a new field atom;
Public "next state" is a new field atom;

/**
 * A {@type "state changed event handler statement"} establishes how to handle a
 * transition of a Blink's own {@code "state"} variable.
 *
 * @type "state changed event handler statement"
 * @supertype "event handler statement"
 * @field "handled event" "state changed's type"
 * @field "previous state" "atom"
 *        The state being transitioned away from.
 * @field "next state" "atom"
 *        The state being transitioned to.
 */
Public class "state changed event handler statement"
	extends event handler statement
	with fields
		public handled event : state changed's type ("_'s⁇event"),
		public previous state : atom,
		public next state : atom;

Method "“_”" is
[
	stmt : state changed event handler statement
|
	try
	[
		format "‘①’ (‘②’ → ‘③’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's previous state's name,
			stmt's next state's name
	]
	else [“(stmt :: any)”]
];

/**
 * A {@type "neighborhood state changed event handler statement"} establishes
 * how to handle a transition of the {@code "state"} variable of one or more
 * neighboring Blinks.
 *
 * @type "neighborhood state changed event handler statement"
 * @supertype "event handler statement"
 * @field "handled event" "neighborhood state changed's type"
 * @field "previous state" "atom"
 *        The state being transitioned away from.
 * @field "next state" "atom"
 *        The state being transitioned to.
 */
Public class "neighborhood state changed event handler statement"
	extends event handler statement
	with fields
		public handled event : neighborhood state changed's type ("_'s⁇event"),
		public previous state : atom,
		public next state : atom;

Method "“_”" is
[
	stmt : neighborhood state changed event handler statement
|
	try
	[
		format "‘①’ (‘②’ → ‘③’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's previous state's name,
			stmt's next state's name
	]
	else [“(stmt :: any)”]
];

Public "handled timer" is a new field atom;
Public "declared timer threshold" is a new field atom;

/**
 * A {@type "timer threshold event handler statement"} establishes how to handle
 * a {@type "timer"} reaching a particular threshold of time remaining.
 *
 * @type "timer threshold event handler statement"
 * @supertype "event handler statement"
 * @field "handled event" "timer threshold's type"
 * @field "handled timer" "timer"
 *        The {@type "timer"}.
 * @field "declared timer threshold" "whole number ms"
 *        The threshold of time remaining.
 */
Public class "timer threshold event handler statement"
	extends event handler statement
	with fields
		public handled event : timer threshold's type ("_'s⁇event"),
		public handled timer : timer ("_'s⁇timer"),
		public declared timer threshold : whole number ms ("_'s⁇threshold");

Method "“_”" is
[
	stmt : timer threshold event handler statement
|
	try
	[
		format "‘①’ (‘②’ : “③”)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's timer's name,
			stmt's threshold
	]
	else [“(stmt :: any)”]
];

/**
 * A {@type "timer expired event handler statement"} establishes how to handle
 * the expiration of a particular {@type "timer"}.
 *
 * @type "timer expired event handler statement"
 * @supertype "event handler statement"
 * @field "handled event" "timer expired's type"
 * @field "handled timer" "timer"
 *        The expired {@type "timer"}.
 */
Public class "timer expired event handler statement"
	extends event handler statement
	with fields
		public handled event : timer expired's type ("_'s⁇event"),
		public handled timer : timer ("_'s⁇timer");

Method "“_”" is
[
	stmt : timer expired event handler statement
|
	try
	[
		format "‘①’ (‘②’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's timer's name
	]
	else [“(stmt :: any)”]
];

/******************************************************************************
 *                         Signal handler statements.                         *
 ******************************************************************************/

Public "handled signal" is a new field atom;

/**
 * A {@type "signal handler statement"} establishes that a particular {@type
 * "signal"} will execute a specific {@type "block expression" block of code}.
 *
 * @type "signal handler statement"
 * @supertype "abstract statement"
 * @field "statement scope" "global's type"
 *        A {@type "signal handler statement"} is always {@type "global"}.
 * @field "handled signal" "signal"
 *        The {@type "signal"} handled by the {@type
 *        "signal handler statement"}.
 * @field "handler block" "block expression"
 *        The {@type "block expression" block of code} that implements the logic
 *        of the {@type "signal handler statement"}.
 */
Public class "signal handler statement" extends abstract statement
	with fields
		public statement scope : global's type ("_'s⁇scope"),
		public handled signal : signal ("_'s⁇signal"),
		public handler block : block expression ("_'s⁇block");

Public method "_'s⁇subexpressions" is
	[stmt : signal handler statement | <stmt's block>];

Method "“_”" is
[
	stmt : signal handler statement
|
	try
	[
		format "‘①’ (‘②’)" with
			(a|an) “stmt's type's names→tuple[1]”,
			stmt's signal's name
	]
	else [“(stmt :: any)”]
];

/******************************************************************************
 *                           Assignment statements.                           *
 ******************************************************************************/

Public "assignment assignee" is a new field atom;
Public "assignment value" is a new field atom;

/**
 * An {@type "assignment statement"} assigns a value to a {@type "variable"}.
 *
 * @type "assignment expression"
 * @supertype "abstract statement"
 * @field "assignment assignee" "variable"
 *        The {@type "variable"} that is the target of the {@type
 *        "assignment statement"}.
 * @field "assignment value" "any expression"
 *        The value that should be bound to the target {@type "variable"}.
 */
Public class "assignment statement" extends abstract statement
	with fields
		public assignment assignee : variable ("_'s⁇assignee"),
		public assignment value : any expression ("_'s⁇value");

Public method "_'s⁇subexpressions" is
[
	expr : assignment statement
|
	/* Don't include the target variable as a subexpression. */
	<expr's value>
];

/******************************************************************************
 *                          Conditional expressions.                          *
 ******************************************************************************/

Public "conditional predicate" is a new field atom;
Public "positive block" is a new field atom;
Public "negative block" is a new field atom;

/**
 * A {@type "conditional statement"} evaluates a {@type "block expression"} iff
 * the predicate is {@method "true"}.
 *
 * @type "conditional statement"
 * @supertype "abstract statement"
 * @field "conditional predicate" "boolean expression"
 *        The predicate.
 * @field "positive block" "block expression"
 *        A {@type "block expression"} that is only evaluated iff the predicate
 *        is {@method "true"}. Must not produce a value.
 */
Public class "conditional statement" extends abstract statement
	with fields
		public statement scope : local's type ("_'s⁇scope"),
		public conditional predicate : boolean expression ("_'s⁇predicate"),
		public positive block : block expression;

Public method "_'s⁇subexpressions" is
[
	expr : conditional statement
|
	<expr's predicate, expr's positive block>
];

/**
 * A {@type "conditional expression"} evaluates a predicate and answers the
 * result of the first {@type "block expression"} if the predicate is {@method
 * "true"} and the second if the predicate is {@method "false"}.
 *
 * @type "conditional expression"
 * @supertype "abstract expression"
 * @field "conditional predicate" "boolean expression"
 *        The predicate.
 * @field "positive block" "block expression"
 *        The {@type "block expression"} to evaluate iff the predicate is
 *        {@method "true"}.
 * @field "negative block" "block expression"
 *        The {@type "block expression"} to evaluate iff the predicate is
 *        {@method "false"}.
 */
Public class "conditional expression" extends abstract expression
	with fields
		public conditional predicate : boolean expression ("_'s⁇predicate"),
		public positive block : block expression,
		public negative block : block expression;

Public method "_'s⁇subexpressions" is
[
	expr : conditional expression
|
	<expr's predicate, expr's positive block, expr's negative block>
];

/******************************************************************************
 *                           Operator expressions.                            *
 ******************************************************************************/

Public "expression operator" is a new field atom;
Public "expression operands" is a new field atom;

/**
 * An {@type "operator expression"} performs an operation on zero (0) or more
 * operands.
 *
 * @type "operator expression"
 * @supertype "abstract expression"
 * @field "expression type" "any's type"
 * @field "expression operator" "nonempty string"
 *        The operator for the expression. This should resemble an Avail
 *        message, e.g., "_+_".
 * @field "expression operands" "any expression*"
 *        The operands.
 */
Public class "operator expression" extends any expression
	with fields
		public expression operator : nonempty string ("_'s⁇operator"),
		public expression operands : any expression* ("_'s⁇operands");

/**
 * Answer the arity of the specified {@type "operator expression"}.
 *
 * @method "_'s⁇arity"
 * @param "expr" "operator expression"
 * @returns "whole number"
 */
Public method "_'s⁇arity" is
[
	expr : operator expression
|
	|expr' operands|
];

/**
 * Strengthen the arity at compile time.
 *
 * @method "_'s⁇arity"
 * @restricts "operator expression's type"
 */
Semantic restriction "_'s⁇arity" is
[
	exprType : operator expression's type
|
	||exprType's operands||
];

Public method "_'s⁇subexpressions" is
[
	expr : operator expression
|
	expr's operands
];

/******************************************************************************
 *                            Signal expressions.                             *
 ******************************************************************************/

Public "fired signal" is a new field atom;

/**
 * A {@type "fire signal statement"} causes a {@type "signal"} to be fired and
 * therefore subsequently handled by an applicable handler.
 *
 * @type "fire signal statement"
 * @supertype "abstract statement"
 * @field "statement scope" "local's type"
 * @field "fired signal" "signal"
 *        The {@type "signal"} to fire.
 */
Public class "fire signal statement" extends abstract statement
	with field
		public statement scope : local's type ("_'s⁇scope"),
		public fired signal : signal ("_'s⁇signal");

Public method "_'s⁇subexpressions" is [stmt : fire signal statement | <>];

/******************************************************************************
 *                             Timer expressions.                             *
 ******************************************************************************/

Public "target timer" is a new field atom;

/**
 * A {@type "timer query expression"} obtains time remaining until expiration
 * for a particular {@type "timer"}.
 *
 * @type "timer query expression"
 * @supertype "abstract expression"
 * @field "expression type" "whole number ms's type"
 * @field "target timer" "timer"
 *        The {@type "timer"} to query.
 */
Public class "timer query expression" extends abstract expression
	with field
		public expression type : whole number ms's type,
		public target timer : timer ("_'s⁇timer");

Public method "_'s⁇subexpressions" is
	[expr : timer query expression | <>];

Public "timer value" is a new field atom;

/**
 * A {@type "timer set statement"} directs a {@type "timer"} to expire in a
 * specified number of {@type "ms" milliseconds}.
 *
 * @type "timer set statement"
 * @supertype "abstract statement"
 * @field "statement scope" "local's type"
 * @field "target timer" "timer"
 *        The {@type "timer"} to set.
 * @field "timer value" "whole number ms expression"
 *        How many {@type "ms" milliseconds} to expire the {@type "timer"} in.
 */
Public explicit class "timer set statement" extends abstract statement
	with field
		public statement scope : local's type ("_'s⁇scope"),
		public target timer : timer ("_'s⁇timer"),
		public timer value : whole number ms expression ("_'s⁇value");

Public method "_'s⁇subexpressions" is
	[stmt : timer set statement | <stmt's value>];

/**
 * A {@type "timer update statement"} adjusts a {@type "timer"}'s expiration
 * time by the specified number of {@type "ms" milliseconds}.
 *
 * @type "timer update statement"
 * @supertype "abstract statement"
 * @field "statement scope" "local's type"
 * @field "target timer" "timer"
 *        The {@type "timer"} to update.
 * @field "timer value" "whole number ms expression"
 *        How many {@type "ms" milliseconds} to adjust the {@type "timer"} by.
 */
Public explicit class "timer update statement" extends abstract statement
	with field
		public statement scope : local's type ("_'s⁇scope"),
		public target timer : timer ("_'s⁇timer"),
		public timer value : integer ms expression ("_'s⁇value");

Public method "_'s⁇subexpressions" is
	[stmt : timer update statement | <stmt's value>];

/******************************************************************************
 *                              Blink programs.                               *
 ******************************************************************************/

/**
 * A {@type "program" program} comprises {@type "abstract expression"
 * statements}.
 *
 * @type "program"
 * @returns "literal phrase ⇒ (abstract statement*'s type)"
 */
Public macro "program" is [‘abstract statement*’];

/**
 * The {@type "module"} that implements the entire {@global "program"}.
 * Currently, a Blink program must not cross Avail {@type "module"} boundaries;
 * it must reside completely within a single {@type "module"}.
 *
 * @global "programModule"
 */
programModule : module;

/**
 * The {@type "program" program} actively undergoing compilation.
 *
 * @global "programAccumulator" "program"
 */
programAccumulator : program := <>;

/**
 * Answer the {@type "global" program accumulator}.
 *
 * @method "program accumulator"
 * @returns "program"
 */
Public read-only variable programAccumulator is "program accumulator";

/**
 * The handled {@type "event"}s. Registration of {@type "events"} supports
 * uniqueness of handlers, permitting the compiler to reject attempts to define
 * conflicting handlers.
 *
 * @global "handledEvents" "{event|}"
 */
handledEvents : {event|} := ∅;

/**
 * The handled {@type "state changed"} {@type "event"}s. Registration of these
 * events supports uniqueness of handlers, permitting the compiler to reject
 * attempts to define conflicting handlers.
 */
handledStateChangeEvents : {<atom…|2>|} := ∅;

/**
 * The handled {@type "neighborhood state changed"} {@type "event"}s.
 * Registration of these events supports uniqueness of handlers, permitting the
 * compiler to reject attempts to define conflicting handlers.
 */
handledNeighborhoodStateChangeEvents : {<atom…|2>|} := ∅;

/**
 * The handled {@type "timer expired"} {@type "event"}s. Registration of these
 * events supports uniqueness of handlers, permitting the compiler to reject
 * attempts to define conflicting handlers.
 */
handledTimerExpirationEvents : {timer|} := ∅;

/**
 * The handled {@type "timer threshold"} {@type "event"}s. Registration of these
 * events supports uniqueness of handlers, permitting the compiler to reject
 * attempts to define conflicting handlers.
 */
handledTimerThresholdEvents : {<timer, whole number ms…|2>|} := ∅;

/**
 * The handled {@type "signal"}s. Registration of {@type "signal"}s supports
 * uniqueness of handlers, permitting the compiler to reject attempts to define
 * conflicting handlers.
 *
 * @global "handledSignals" "{signal|}"
 */
handledSignals : {signal|} := ∅;

/**
 * Record the specified {@type "module"} as the one containing the entire Blink
 * {@method "program accumulator" program}. Splitting a Blink program across
 * {@type "module"}s is currently unsupported.
 *
 * @method "Record module_"
 * @param "mod" "module"
 * @returns "⊤"
 */
Private method "Record module_" is
[
	mod : module
|
	programModule := mod;
	After the current module is unloaded, do
	[
		programAccumulator := <>;
		handledEvents := ∅;
		handledStateChangeEvents := ∅;
		handledNeighborhoodStateChangeEvents := ∅;
		handledTimerThresholdEvents := ∅;
		handledTimerExpirationEvents := ∅;
		handledSignals := ∅;
		Clear programModule;
	];
];

/**
 * Register that a handler exists for the specified {@type "event"}.
 *
 * @method "Register event handler for_"
 * @param "ev" "event"
 * @returns "⊤"
 */
Private method "Register event handler for_" is
[
	ev : event
|
	handledEvents := handledEvents + ev;
];

/**
 * Register that a handler exists for personal transitions from one state to
 * another.
 *
 * @method "Register state changed from_to_handler"
 * @param "old" "atom"
 * @param "new" "atom"
 * @returns "⊤"
 */
Private method "Register state changed from_to_handler" is
[
	old : atom,
	new : atom
|
	handledStateChangeEvents := handledStateChangeEvents + <old, new>;
];

/**
 * Register that a handler exists for neighborhood transitions from one state to
 * another.
 *
 * @method "Register neighborhood state changed from_to_handler"
 * @param "old" "atom"
 * @param "new" "atom"
 * @returns "⊤"
 */
Private method "Register neighborhood state changed from_to_handler" is
[
	old : atom,
	new : atom
|
	handledNeighborhoodStateChangeEvents :=
		handledNeighborhoodStateChangeEvents + <old, new>;
];

/**
 * Register that a handler exists for the specified {@type "timer"} reaching a
 * particular threshold.
 *
 * @method "Register timer threshold handler for_at_"
 * @param "t" "timer"
 * @param "th" "whole number ms"
 * @returns "⊤"
 */
Private method "Register timer threshold handler for_at_" is
[
	t : timer,
	th : whole number ms
|
	handledTimerThresholdEvents := handledTimerThresholdEvents + <t, th>;
];

/**
 * Register that a handler exists for the expiration of the specified {@type
 * "timer"}.
 *
 * @method "Register timer expiration handler for_"
 * @param "t" "timer"
 * @returns "⊤"
 */
Private method "Register timer expiration handler for_" is
[
	t : timer
|
	handledTimerExpirationEvents := handledTimerExpirationEvents + t;
];

/**
 * Register that a handler exists for the specified {@type "signal"}.
 *
 * @method "Register signal handler for_"
 * @param "sig" "signal"
 * @returns "⊤"
 */
Private method "Register signal handler for_" is
[
	sig : signal
|
	handledSignals := handledSignals + sig;
];

/**
 * Answer {@type "statement phrase" Avail statements} capable of appending the
 * specified {@type "abstract expression" statement} onto the {@method
 * "program accumulator"}. {@method "Reject parse,expected:_" Reject the current
 * parse} if the {@type "abstract expression" statement} came from a different
 * {@type "module"} than the previously recorded {@type "abstract expression"
 * statement}.
 *
 * This method must only be called from macros. It cannot be called at runtime.
 *
 * @method "statement recorder for_"
 * @param "expr" "abstract statement"
 * @returns "statement phrase+"
 */
Public method "statement recorder for_" is
[
	expr : abstract statement
|
	Assert: expr's scope = global (format "“①” is not global!" with expr);
	If expr's expression type ≠ ⊤ then
	[
		Reject parse, expected:
			format "expression to be a statement (but it returns “①”)"
			with expr's expression type
	];
	mod ::= current module;
	stmts : statement phrase+ :=
	<
		send $"_++=_" with «<‘↑programAccumulator’, «<‘expr’>»>» : ⊤
			→ statement phrase
	>;
	If programModule is unassigned then
	[
		stmts :=
			<send $"Record module_" with «<‘mod’>» : ⊤ → statement phrase>
			++ stmts;
	]
	else if programModule ≠ mod then
	[
		Reject parse, expected:
			format
				"the entire Blink program to reside in module “①” (but \
				\this is module “②”)"
			with
				programModule's name,
				mod's name
	];
	Cast expr into
	[
		h : state changed event handler statement
	|
		old ::= h's previous state;
		new ::= h's next state;
		If <old, new> ∈ handledStateChangeEvents then
		[
			Reject parse, expected:
				format
					"each state changed event handler to be unique (but there \
					\|is already a handler for ‘①’ → ‘②’)"
				with
					old's name,
					new's name
		];
		stmts ++=
			<send $"Register state changed from_to_handler"
				with «<‘old’, ‘new’>» : ⊤ → statement phrase>;
	]
	else [/* Nothing. */];
	Cast expr into
	[
		h : neighborhood state changed event handler statement
	|
		old ::= h's previous state;
		new ::= h's next state;
		If <old, new> ∈ handledNeighborhoodStateChangeEvents then
		[
			Reject parse, expected:
				format
					"each neighborhood state changed event handler to be \
					\|unique (but there is already a handler for ‘①’ → ‘②’)"
				with
					old's name,
					new's name
		];
		stmts ++=
			<send $"Register neighborhood state changed from_to_handler"
				with «<‘old’, ‘new’>» : ⊤ → statement phrase>;
	]
	else [/* Nothing. */];
	Cast expr into
	[
		h : timer threshold event handler statement
	|
		t ::= h's timer;
		th ::= h's threshold;
		If <t, th> ∈ handledTimerThresholdEvents then
		[
			Reject parse, expected:
				format
					"each timer theshold handler to be unique (but there \
					\|is already a handler for ‘①’ at “②”)"
				with
					t's name,
					th
		];
		stmts ++=
			<send $"Register timer threshold handler for_at_"
				with «<‘t’, ‘th’>» : ⊤ → statement phrase>;
	]
	else [/* Nothing. */];
	Cast expr into
	[
		h : timer expired event handler statement
	|
		t ::= h's timer;
		If t ∈ handledTimerExpirationEvents then
		[
			Reject parse, expected:
				format
					"each timer expiration handler to be unique (but there \
					\|is already a handler for ‘①’)"
				with
					t's name
		];
		stmts ++=
			<send $"Register timer expiration handler for_"
				with «<‘t’>» : ⊤ → statement phrase>;
	]
	else [/* Nothing. */];
	Cast expr into
	[
		h : event handler statement
	|
		ev ::= h's event;
		If h's event ∈ handledEvents then
		[
			Reject parse, expected:
				format
					"each event handler to be unique (but there is already a \
					\|handler for ‘①’)"
				with
					ev's name
		];
		stmts ++=
			<send $"Register event handler for_"
				with «<‘ev’>» : ⊤ → statement phrase>;
	]
	else [/* Nothing. */];
	Cast expr into
	[
		h : signal handler statement
	|
		sig ::= h's signal;
		If h's signal ∈ handledSignals then
		[
			Reject parse, expected:
				format
					"each signal handler to be unique (but there is already a \
					\|handler for ‘①’)"
				with
					sig's name
		];
		stmts ++=
			<send $"Register signal handler for_"
				with «<‘sig’>» : ⊤ → statement phrase>;
	]
	else [/* Nothing. */];
	stmts
] : statement phrase+;

/**
 * Perform a raw dump of the {@method "program accumulator"} to standard output.
 *
 * @method "*Dump program"
 * @returns "⊤"
 */
Private method "*Dump program" is
[
	For each stmt of programAccumulator do
	[
		Print: “stmt” ++ "\n";
	];
];
