/*
 * Abstract Syntax Tree.avail
 * Copyright (c) Todd L Smith and Taylor DH Smith, 2017.
 * All rights reserved.
 */

Module "Abstract Syntax Tree"
Uses
	"Avail" =
	(
		"variable" → "Avail variable",
		…
	)
Extends
	"Lighting Modes",
	"Lighting Patterns",
	"Timers"
Names
	/* Abstract expressions. */
	"abstract expression",
		"expression type",
			"_'s⁇expression type",
	"_'s⁇subexpressions",
	"_expression",

	/* Abstract statements. */
	"abstract statement",

	/* Literals. */
	"literal",
		"_'s⁇value",
	"_literal",

	/* Variables. */
	"variable",
		"variable name",
			"_'s⁇name",
		"variable scope",
			"_'s⁇scope",
	"scope",
		"local",
		"global",
	"__variable",
	"_variable",

	/* State enumeration statements. */
	"state enumeration statement",
		"declared states",
			"_'s⁇states",

	/* Programs. */
	"program",
	"program accumulator",
	"statement recorder for_"
Body

/*
 * 2017.05.24 — The AST is kept minimal, to satisfy the prototype simulator and
 * its lone game, "Mortals". Only those features necessary to support "Mortals"
 * have been built.
 */

/******************************************************************************
 *                           Abstract expressions.                            *
 ******************************************************************************/

Public "expression type" is a new field atom;

/**
 * An {@type "abstract expression"} represents any Blink expression. It is
 * parametric on the static {@type "type"} of the Blink expression.
 *
 * @type "abstract expression"
 * @supertype "object"
 * @field "expression type" "⊤'s type"
 *        The static {@type "type"} of the {@type "abstract expression"
 *        expression}.
 */
Public class "abstract expression" extends object
	with field
		public expression type : ⊤'s type;

Alias "abstract statement" to $"abstract expression";

/**
 * Construct a {@type "abstract expression" Blink expression} {@type "type"} for
 * the specified {@type "type"}.
 *
 * @method "_expression"
 * @param "exprType" "⊤'s type"
 * @returns "abstract expression's type"
 */
Public method "_expression" is
[
	exprType : ⊤'s type
|
	extend abstract expression with expression type : (exprType's type)
];

/**
 * Strengthen the {@type "abstract expression" Blink expression} {@type "type"}
 * at compile time.
 *
 * @method "_expression"
 * @restricts "⊤'s type's type"
 */
Semantic restriction "_expression" is
[
	exprMeta : ⊤'s type's type
|
	(extend abstract expression with
		expression type : exprMeta)'s type
];

/**
 * Answer the {@type "abstract expression" subexpressions} of the specified
 * {@type "abstract expression" expression}.
 *
 * @method "_'s⁇subexpressions"
 * @param "expr" "abstract expression"
 * @returns "abstract expression*"
 */
Public abstract method "_'s⁇subexpressions" is
	[abstract expression]→abstract expression*;

/******************************************************************************
 *                                 Literals.                                  *
 ******************************************************************************/

/**
 * A {@type "literal"} denotes a statically known value. The {@field
 * "expression type"} of a {@type "literal"} must be an instance {@type
 * "any's type" type}.
 *
 * @type "literal"
 * @supertype "abstract expression"
 * @field "expression type" "any's type"
 */
Public explicit class "literal" extends abstract expression
	with field
		public expression type : any's type;

/**
 * Answer the {@type "any" value} that the specified {@type "literal"} denotes.
 *
 * @method "_'s⁇value"
 * @param "lit" "literal"
 * @returns "any"
 */
Public method "_'s⁇value" is
[
	lit : literal
|
	lit's expression type's instance
];

/**
 * Strengthen the {@type "literal"}'s {@type "_'s⁇value" value} {@type "type"}
 * at compile time.
 *
 * @method "_'s⁇value"
 * @restricts "literal's type"
 */
Semantic restriction "_'s⁇value" is
[
	litType : literal's type
|
	litType's expression type's instance
];

/**
 * Construct a {@type "literal"} {@type "type"} for the specified {@type
 * "type"}.
 *
 * @method "_literal"
 * @param "valueType" "any's type"
 * @returns "literal's type"
 */
Public method "_literal" is
[
	valueType : any's type
|
	extend literal with expression type : (valueType's type)
];

/**
 * Strengthen the {@type "literal"} {@type "type"} at compile time.
 *
 * @method "_literal"
 * @restricts "any's type's type"
 */
Semantic restriction "_literal" is
[
	exprMeta : any's type's type
|
	(extend literal with expression type : exprMeta)'s type
];

Public method "_'s⁇subexpressions" is [lit : literal| <>];

/******************************************************************************
 *                                 Variables.                                 *
 ******************************************************************************/

/**
 * Answer an {@type "atom"} that denotes local scope.
 *
 * @method "local"
 * @returns "atom"
 */
Public "local" is a new atom;

/**
 * Answer an {@type "atom"} that denotes global scope.
 *
 * @method "global"
 * @returns "atom"
 */
Public "global" is a new atom;

/**
 * A {@type "scope"} denotes the scope of a {@type "variable"}, either {@method
 * "local"} or {@method "global"}.
 *
 * @type "scope"
 * @alias "{local, global}ᵀ"
 */
Public macro "scope" is [‘{local, global}ᵀ’];

"variable name" is a new field atom;
"variable scope" is a new field atom;

/**
 * A {@type "variable"} represents a statically typed fundamental storage unit
 * in a Blink program.
 *
 * @type "variable"
 * @supertype "abstract expression"
 * @param "variable name" "nonempty string"
 *        The lexical name of the {@type "variable"}.
 * @param "expression type" "any's type"
 * @param "variable scope" "scope"
 *        The {@type "scope"} of the {@type "variable"}, either {@method
 *        "local"} or {@type "global"}.
 */
Public class "variable" extends abstract expression
	with fields
		public variable name : nonempty string ("_'s⁇name"),
		public expression type : any's type,
		public variable scope : scope ("_'s⁇scope");

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type} and {@type "scope"}.
 *
 * @method "__variable"
 * @param "varType" "any's type"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "__variable" is
[
	varType : any's type,
	scopeType : scope
|
	extend variable with
		expression type : (varType's type),
		variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "__variable"
 * @restricts "any's type's type"
 * @restricts "scope's type"
 */
Semantic restriction "__variable" is
[
	varMeta : any's type's type,
	scopeMeta : scope's type
|
	(extend variable with
		expression type : varMeta,
		variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "scope"}.
 *
 * @method "_variable"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	scopeType : scope
|
	extend variable with variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "scope's type"
 */
Semantic restriction "_variable" is
[
	scopeMeta : scope's type
|
	(extend variable with variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type}.
 *
 * @method "_variable"
 * @param "varType" "any's type"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	varType : any's type
|
	extend variable with expression type : (varType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "any's type's type"
 */
Semantic restriction "_variable" is
[
	varMeta : any's type's type
|
	(extend variable with expression type : varMeta)'s type
];

Public method "_'s⁇subexpressions" is [var : variable | <>];

/******************************************************************************
 *                       State enumeration statements.                        *
 ******************************************************************************/

Public "declared states" is a new field atom;

/**
 * A {@type "state enumeration statement"} establishes the publicly available
 * Blink states. These are transmitted via IR. There must not be more than one
 * of these per program.
 *
 * @type "state enumeration statement"
 * @supertype "abstract statement"
 * @field "declared states" "{atom|}"
 *        All declared states. These are the only valid states for a particular
 *        program.
 */
Public class "state enumeration statement" extends abstract statement
	with fields
		public declared states : {atom|} ("_'s⁇states");

/******************************************************************************
 *                              Blink programs.                               *
 ******************************************************************************/

/**
 * A {@type "program" program} comprises {@type "abstract expression"
 * statements}.
 *
 * @type "program"
 * @returns "literal phrase ⇒ (abstract statement*'s type)"
 */
Public macro "program" is [‘abstract statement*’];

/**
 * The {@type "module"} that implements the entire {@global "program"}.
 * Currently, a Blink program must not cross Avail {@type "module"} boundaries;
 * it must reside completely within a single {@type "module"}.
 *
 * @global "programModule"
 */
programModule : module;

/**
 * The {@type "program" program} actively undergoing compilation.
 *
 * @global "programAccumulator" "program"
 */
programAccumulator : program := <>;

/**
 * Answer the {@type "global" program accumulator}.
 *
 * @method "program accumulator"
 * @returns "program"
 */
Public read-only variable programAccumulator is "program accumulator";

/**
 * Record the specified {@type "module"} as the one containing the entire Blink
 * {@method "program accumulator" program}. Splitting a Blink program across
 * {@type "module"}s is currently unsupported.
 *
 * @method "Record module_"
 * @param "mod" "module"
 * @returns "⊤"
 */
Private method "Record module_" is
[
	mod : module
|
	programModule := mod;
	After the current module is unloaded, do
	[
		programAccumulator := <>;
		Clear programModule;
	];
];

/**
 * Answer {@type "statement phrase" Avail statements} capable of appending the
 * specified {@type "abstract expression" statement} onto the {@method
 * "program accumulator"}. {@method "Reject parse,expected:_" Reject the current
 * parse} if the {@type "abstract expression" statement} came from a different
 * {@type "module"} than the previously recorded {@type "abstract expression"
 * statement}.
 *
 * This method must only be called from macros. It cannot be called at runtime.
 *
 * @method "statement recorder for_"
 * @param "expr" "abstract statement"
 * @returns "statement phrase+"
 */
Public method "statement recorder for_" is
[
	expr : abstract statement
|
	If expr's expression type ≠ ⊤ then
	[
		Reject parse, expected:
			format "expression to be a statement (but it returns “①”)"
			with expr's expression type
	];
	mod ::= current module;
	stmts : statement phrase+ :=
	<
		send $"_++=_" with «<‘↑programAccumulator’, «<‘expr’>»>» : ⊤
			→ statement phrase
	>;
	If programModule is unassigned then
	[
		stmts :=
			<send $"Record module_" with «<‘mod’>» : ⊤ → statement phrase>
			++ stmts;
	]
	else if programModule ≠ mod then
	[
		Reject parse, expected:
			format
				"the entire Blink program to reside in module “①” (but \
				\this is module “②”)"
			with
				programModule's name,
				mod's name
	];
	stmts
] : statement phrase+;
