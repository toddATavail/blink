/*
 * Abstract Syntax Tree.avail
 * Copyright (c) Todd L Smith and Taylor DH Smith, 2017.
 * All rights reserved.
 */

Module "Abstract Syntax Tree"
Uses
	"Avail" =
	(
		"variable" → "Avail variable",
		…
	)
Extends
	"Lighting Modes",
	"Lighting Patterns",
	"Timers"
Names
	/* Abstract expressions. */
	"abstract expression",
		"expression type",
			"_'s⁇expression type",
	"_'s⁇subexpressions",
	"_expression",

	/* Abstract statements. */
	"abstract statement",
		"expression scope",
			"_'s⁇scope",

	/* Literals. */
	"literal",
		"_'s⁇value",
	"_literal",

	/* Variables. */
	"variable",
		"variable name",
			"_'s⁇name",
		"variable scope",
			/*"_'s⁇scope",*/
		"variable mutability",
			"_'s⁇mutability",
	"scope",
		"local",
		"global",
	"mutability",
		"immutable",
		"mutable",
	"___variable",
	"__variable",
	"_variable",
	
	/* Signals. */
	"signal",
		"signal name",
			/*"_'s⁇name",*/

	/* Variable declaration statements. */
	"variable declaration statement",
		"declared variable",
			"_'s⁇variable",

	/* Signal declaration statements. */
	"signal declaration statement",
		"declared signal",
			"_'s⁇signal",

	/* State enumeration statements. */
	"state enumeration statement",
		"declared states",
			"_'s⁇states",

	/* Assignment statements. */
	"assignment statement",
		"assignment assignee",
			"_'s⁇assignee",
		"assignment value",
			/*"_'s⁇value",*/

	/* Block expressions. */
	"block expression",
		"block body",
			"_'s⁇body",

	/* Programs. */
	"program",
	"program accumulator",
	"statement recorder for_"
Entries
	"*Dump program"
Body

/*
 * 2017.05.24 — The AST is kept minimal, to satisfy the prototype simulator and
 * its lone game, "Mortals". Only those features necessary to support "Mortals"
 * have been built.
 */

/******************************************************************************
 *                           Abstract expressions.                            *
 ******************************************************************************/

Public "expression type" is a new field atom;

/**
 * An {@type "abstract expression"} represents any Blink expression. It is
 * parametric on the static {@type "type"} of the Blink expression.
 *
 * @type "abstract expression"
 * @supertype "object"
 * @field "expression type" "⊤'s type"
 *        The static {@type "type"} of the {@type "abstract expression"
 *        expression}.
 * @field "expression scope" "scope"
 *        The {@type "scope"} of the {@type "abstract expression" expression}.
 */
Public class "abstract expression" extends object
	with field
		public expression type : ⊤'s type;

/**
 * Construct a {@type "abstract expression" Blink expression} {@type "type"} for
 * the specified {@type "type"}.
 *
 * @method "_expression"
 * @param "exprType" "⊤'s type"
 * @returns "abstract expression's type"
 */
Public method "_expression" is
[
	exprType : ⊤'s type
|
	extend abstract expression with expression type : (exprType's type)
];

/**
 * Strengthen the {@type "abstract expression" Blink expression} {@type "type"}
 * at compile time.
 *
 * @method "_expression"
 * @restricts "⊤'s type's type"
 */
Semantic restriction "_expression" is
[
	exprMeta : ⊤'s type's type
|
	(extend abstract expression with
		expression type : exprMeta)'s type
];

/**
 * Answer the {@type "abstract expression" subexpressions} of the specified
 * {@type "abstract expression" expression}.
 *
 * @method "_'s⁇subexpressions"
 * @param "expr" "abstract expression"
 * @returns "abstract expression*"
 */
Public abstract method "_'s⁇subexpressions" is
	[abstract expression]→abstract expression*;

/******************************************************************************
 *                                   Scope.                                   *
 ******************************************************************************/

/**
 * Answer an {@type "atom"} that denotes local scope.
 *
 * @method "local"
 * @returns "atom"
 */
Public "local" is a new atom;

/**
 * Answer an {@type "atom"} that denotes global scope.
 *
 * @method "global"
 * @returns "atom"
 */
Public "global" is a new atom;

/**
 * A {@type "scope"} denotes the scope of a {@type "variable"}, either {@method
 * "local"} or {@method "global"}.
 *
 * @type "scope"
 * @alias "{local, global}ᵀ"
 */
Public macro "scope" is [‘{local, global}ᵀ’];

/******************************************************************************
 *                            Abstract statements.                            *
 ******************************************************************************/

Public "expression scope" is a new field atom;

/**
 * An {@type "abstract statement"} represents any Blink statement. It is always
 * {@type "⊤"}-valued.
 *
 * @type "abstract statement"
 * @supertype "abstract expression"
 * @field "expression scope" "scope"
 *        The {@type "scope"} of the {@type "abstract expression" expression}.
 */
Public class "abstract statement" extends abstract expression
	with field
		public expression scope : scope ("_'s⁇scope");

/******************************************************************************
 *                                 Literals.                                  *
 ******************************************************************************/

/**
 * A {@type "literal"} denotes a statically known value. The {@field
 * "expression type"} of a {@type "literal"} must be an instance {@type
 * "any's type" type}.
 *
 * @type "literal"
 * @supertype "abstract expression"
 * @field "expression type" "any's type"
 */
Public explicit class "literal" extends abstract expression
	with field
		public expression type : any's type;

/**
 * Answer the {@type "any" value} that the specified {@type "literal"} denotes.
 *
 * @method "_'s⁇value"
 * @param "lit" "literal"
 * @returns "any"
 */
Public method "_'s⁇value" is
[
	lit : literal
|
	lit's expression type's instance
];

/**
 * Strengthen the {@type "literal"}'s {@type "_'s⁇value" value} {@type "type"}
 * at compile time.
 *
 * @method "_'s⁇value"
 * @restricts "literal's type"
 */
Semantic restriction "_'s⁇value" is
[
	litType : literal's type
|
	litType's expression type's instance
];

/**
 * Construct a {@type "literal"} {@type "type"} for the specified {@type
 * "type"}.
 *
 * @method "_literal"
 * @param "valueType" "any's type"
 * @returns "literal's type"
 */
Public method "_literal" is
[
	valueType : any's type
|
	extend literal with expression type : (valueType's type)
];

/**
 * Strengthen the {@type "literal"} {@type "type"} at compile time.
 *
 * @method "_literal"
 * @restricts "any's type's type"
 */
Semantic restriction "_literal" is
[
	exprMeta : any's type's type
|
	(extend literal with expression type : exprMeta)'s type
];

Public method "_'s⁇subexpressions" is [lit : literal| <>];

/******************************************************************************
 *                                 Variables.                                 *
 ******************************************************************************/

/**
 * Answer an {@type "atom"} that denotes immutability.
 *
 * @method "immutable"
 * @return "atom"
 */
Public "immutable" is a new atom;

/**
 * Answer an {@type "atom"} that denotes mutability.
 *
 * @method "mutable"
 * @return "atom"
 */
Public "mutable" is a new atom;

/**
 * A {@type "mutability"} denotes the mutability of a {@type "variable"}, either
 * {@method "immutable"} or {@method "mutable"}.
 *
 * @type "mutability"
 * @alias "{immutable, mutable}ᵀ"
 */
Public macro "mutability" is [‘{immutable, mutable}ᵀ’];

"variable name" is a new field atom;
"variable scope" is a new field atom;
"variable mutability" is a new field atom;

/**
 * A {@type "variable"} represents a statically typed fundamental storage unit
 * in a Blink program.
 *
 * @type "variable"
 * @supertype "abstract expression"
 * @param "variable name" "nonempty string"
 *        The lexical name of the {@type "variable"}.
 * @param "expression type" "any's type"
 * @param "variable scope" "scope"
 *        The {@type "scope"} of the {@type "variable"}, either {@method
 *        "local"} or {@type "global"}.
 * @param "variable mutability" "mutability"
 *        The mutability of a {@type "variable"}, either {@method "immutable"} or
 *        {@method "mutable"}.
 */
Public class "variable" extends abstract expression
	with fields
		public variable name : nonempty string ("_'s⁇name"),
		public expression type : any's type,
		public variable scope : scope ("_'s⁇scope"),
		public variable mutability : mutability ("_'s⁇mutability");

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type}, {@type "scope"}, and {@type "mutability"}.
 *
 * @method "___variable"
 * @param "varType" "any's type"
 * @param "scopeType" "scope"
 * @param "mutabilityType" "mutability"
 * @returns "variable's type"
 */
Public method "___variable" is
[
	varType : any's type,
	scopeType : scope,
	mutabilityType : mutability
|
	extend variable with
		expression type : (varType's type),
		variable scope : (scopeType's type),
		variable mutability : (mutabilityType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "___variable"
 * @restricts "any's type's type"
 * @restricts "scope's type"
 * @restricts "mutability's type"
 */
Semantic restriction "___variable" is
[
	varMeta : any's type's type,
	scopeMeta : scope's type,
	mutabilityMeta : mutability's type
|
	(extend variable with
		expression type : varMeta,
		variable scope : scopeMeta,
		variable mutability : mutabilityMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type} and {@type "scope"}.
 *
 * @method "__variable"
 * @param "varType" "any's type"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "__variable" is
[
	varType : any's type,
	scopeType : scope
|
	extend variable with
		expression type : (varType's type),
		variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "__variable"
 * @restricts "any's type's type"
 * @restricts "scope's type"
 */
Semantic restriction "__variable" is
[
	varMeta : any's type's type,
	scopeMeta : scope's type
|
	(extend variable with
		expression type : varMeta,
		variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "mutability"}.
 *
 * @method "_variable"
 * @param "mutabilityType" "mutability"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	mutabilityType : mutability
|
	extend variable with variable mutability : (mutabilityType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "mutability's type"
 */
Semantic restriction "_variable" is
[
	mutabilityMeta : mutability's type
|
	(extend variable with variable mutability : mutabilityMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "scope"}.
 *
 * @method "_variable"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	scopeType : scope
|
	extend variable with variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "scope's type"
 */
Semantic restriction "_variable" is
[
	scopeMeta : scope's type
|
	(extend variable with variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type}.
 *
 * @method "_variable"
 * @param "varType" "any's type"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	varType : any's type
|
	extend variable with expression type : (varType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "any's type's type"
 */
Semantic restriction "_variable" is
[
	varMeta : any's type's type
|
	(extend variable with expression type : varMeta)'s type
];

Public method "_'s⁇subexpressions" is [var : variable | <>];

/******************************************************************************
 *                                  Signals.                                  *
 ******************************************************************************/

Public "signal name" is a new field atom;

/**
 * A {@type "signal"} is a user-defined event.
 *
 * @type "signal"
 * @supertype "abstract expression"
 * @field "signal name" "nonempty string"
 *        The name of the {@type "signal"}.
 */
Public class "signal" extends abstract expression
	with field
		public signal name : nonempty string ("_'s⁇name");

Public method "_'s⁇subexpressions" is [sig : signal | <>];

/******************************************************************************
 *                      Variable declaration statements.                      *
 ******************************************************************************/

Public "declared variable" is a new field atom;

/**
 * A {@type "variable declaration statement"} declares a {@type "variable"}.
 *
 * @type "variable declaration statement"
 * @supertype "abstract statement"
 * @field "declared variable" "variable"
 *        The {@type "variable"} declared by the {@type
 *        "variable declaration statement"}.
 */
Public class "variable declaration statement" extends abstract statement
 	with field
 		public declared variable : variable ("_'s⁇variable");

Public method "_'s⁇subexpressions" is
	[stmt : variable declaration statement | <>];

Method "“_”" is
[
	stmt : variable declaration statement
|
	var ::= stmt's variable;
	format "‘①’ ‘②’ ‘③’ (‘④’ : “⑤”)" with
		(a|an) “var's mutability's name”,
		var's scope's name,
		stmt's type's names→tuple[1],
		stmt's variable's name,
		stmt's variable's expression type
];

/******************************************************************************
 *                       Signal declaration statements.                       *
 ******************************************************************************/

Public "declared signal" is a new field atom;

/**
 * A {@type "signal declaration statement"} declares a {@type "signal"}.
 *
 * @type "signal declaration statement"
 * @supertype "abstract statement"
 * @field "declared signal" "signal"
 *        The {@type "signal"} declared by the {@type
 *        "signal declaration statement"}.
 * @field "expression scope" "global's type"
 *        A {@type "signal declaration statement"} is always {@type "global"}.
 */
Public class "signal declaration statement" extends abstract statement
	with field
		public declared signal : signal ("_'s⁇signal"),
		public expression scope : global's type ("_'s⁇scope");

Public method "_'s⁇subexpressions" is
	[stmt : signal declaration statement | <>];

Method "“_”" is
[
	stmt : signal declaration statement
|
	sig ::= stmt's signal;
	format "‘①’ (‘②’)" with
		(a|an) “stmt's type's names→tuple[1]”,
		stmt's signal's name
];

/******************************************************************************
 *                       State enumeration statements.                        *
 ******************************************************************************/

Public "declared states" is a new field atom;

/**
 * A {@type "state enumeration statement"} establishes the publicly available
 * Blink states. These are transmitted via IR. There must not be more than one
 * of these per program.
 *
 * @type "state enumeration statement"
 * @supertype "abstract statement"
 * @field "declared states" "atom*"
 *        All declared states. These are the only valid states for a particular
 *        program.
 * @field "expression scope" "global's type"
 *        A {@type "state enumeration statement"} is always {@type "global"}.
 */
Public class "state enumeration statement" extends abstract statement
	with fields
		public declared states : atom* ("_'s⁇states"),
		public expression scope : global's type ("_'s⁇scope");

Public method "_'s⁇subexpressions" is [stmt : state enumeration statement | <>];

Method "“_”" is
[
	stmt : state enumeration statement
|
	format "‘①’ (‘②’)" with
		(a|an) “stmt's type's names→tuple[1]”,
		“map each x of stmt's states through [x's name]” (as simple list)
];

/******************************************************************************
 *                             Block expressions.                             *
 ******************************************************************************/

Public "block body" is a new field atom;

/**
 * A {@type "block expression"} represents a sequence of {@type
 * "abstract statements"} that reside in their own scope.
 *
 * @type "block expression"
 * @supertype "abstract expression"
 * @field "block body" "abstract statement*"
 *        The {@type "abstract statement" statements} that comprise the {@type
 *        "block expression"}.
 */
Public class "block expression" extends abstract expression
	with field
		public block body : abstract statement* ("_'s⁇body");

Public method "_'s⁇subexpressions" is [expr : block expression | expr's body];

/******************************************************************************
 *                          Assignment expressions.                           *
 ******************************************************************************/

Public "assignment assignee" is a new field atom;
Public "assignment value" is a new field atom;

/**
 * An {@type "assignment statement"} assigns a value to a {@type "variable"}.
 *
 * @type "assignment expression"
 * @supertype "abstract statement"
 * @field "assignment assignee" "variable"
 *        The {@type "variable"} that is the target of the {@type
 *        "assignment statement"}.
 * @field "assignment value" "any expression"
 *        The value that should be bound to the target {@type "variable"}.
 */
Public class "assignment statement" extends abstract statement
	with fields
		public assignment assignee : variable ("_'s⁇assignee"),
		public assignment value : any expression ("_'s⁇value");

Public method "_'s⁇subexpressions" is
[
	expr : assignment statement
|
	/* Don't include the target variable as a subexpression. */
	<expr's value>
];

/******************************************************************************
 *                              Blink programs.                               *
 ******************************************************************************/

/**
 * A {@type "program" program} comprises {@type "abstract expression"
 * statements}.
 *
 * @type "program"
 * @returns "literal phrase ⇒ (abstract statement*'s type)"
 */
Public macro "program" is [‘abstract statement*’];

/**
 * The {@type "module"} that implements the entire {@global "program"}.
 * Currently, a Blink program must not cross Avail {@type "module"} boundaries;
 * it must reside completely within a single {@type "module"}.
 *
 * @global "programModule"
 */
programModule : module;

/**
 * The {@type "program" program} actively undergoing compilation.
 *
 * @global "programAccumulator" "program"
 */
programAccumulator : program := <>;

/**
 * Answer the {@type "global" program accumulator}.
 *
 * @method "program accumulator"
 * @returns "program"
 */
Public read-only variable programAccumulator is "program accumulator";

/**
 * Record the specified {@type "module"} as the one containing the entire Blink
 * {@method "program accumulator" program}. Splitting a Blink program across
 * {@type "module"}s is currently unsupported.
 *
 * @method "Record module_"
 * @param "mod" "module"
 * @returns "⊤"
 */
Private method "Record module_" is
[
	mod : module
|
	programModule := mod;
	After the current module is unloaded, do
	[
		programAccumulator := <>;
		Clear programModule;
	];
];

/**
 * Answer {@type "statement phrase" Avail statements} capable of appending the
 * specified {@type "abstract expression" statement} onto the {@method
 * "program accumulator"}. {@method "Reject parse,expected:_" Reject the current
 * parse} if the {@type "abstract expression" statement} came from a different
 * {@type "module"} than the previously recorded {@type "abstract expression"
 * statement}.
 *
 * This method must only be called from macros. It cannot be called at runtime.
 *
 * @method "statement recorder for_"
 * @param "expr" "abstract statement"
 * @returns "statement phrase+"
 */
Public method "statement recorder for_" is
[
	expr : abstract statement
|
	Assert: expr's scope = global (format "“①” is not global!" with expr);
	If expr's expression type ≠ ⊤ then
	[
		Reject parse, expected:
			format "expression to be a statement (but it returns “①”)"
			with expr's expression type
	];
	mod ::= current module;
	stmts : statement phrase+ :=
	<
		send $"_++=_" with «<‘↑programAccumulator’, «<‘expr’>»>» : ⊤
			→ statement phrase
	>;
	If programModule is unassigned then
	[
		stmts :=
			<send $"Record module_" with «<‘mod’>» : ⊤ → statement phrase>
			++ stmts;
	]
	else if programModule ≠ mod then
	[
		Reject parse, expected:
			format
				"the entire Blink program to reside in module “①” (but \
				\this is module “②”)"
			with
				programModule's name,
				mod's name
	];
	stmts
] : statement phrase+;

/**
 * Perform a raw dump of the {@method "program accumulator"} to standard output.
 *
 * @method "*Dump program"
 * @returns "⊤"
 */
Private method "*Dump program" is
[
	For each stmt of programAccumulator do
	[
		Print: “stmt” ++ "\n";
	];
];