/*
 * Abstract Syntax Tree.avail
 * Copyright (c) Todd L Smith and Taylor DH Smith, 2017.
 * All rights reserved.
 */

Module "Abstract Syntax Tree"
Uses
	"Avail" =
	(
		"variable" → "Avail variable",
		…
	)
Extends
	"Lighting Modes",
	"Lighting Patterns",
	"Timers"
Names
	/* Abstract expressions. */
	"abstract expression",
		"expression type",
			"_'s⁇expression type",
	"_'s⁇subexpressions",
	"_expression",

	/* Abstract statements. */
	"abstract statement",

	/* Literals. */
	"literal",
		"_'s⁇value",
	"_literal",

	/* Variables. */
	"variable",
		"variable name",
			"_'s⁇name",
		"variable scope",
			"_'s⁇scope",
	"scope",
		"local",
		"global",
	"__variable",
	"_variable"
Body

/*
 * 2017.05.24 — The AST is kept minimal, to satisfy the prototype simulator and
 * its lone game, "Mortals". Only those features necessary to support "Mortals"
 * have been built.
 */

/******************************************************************************
 *                           Abstract expressions.                            *
 ******************************************************************************/

Public "expression type" is a new field atom;

/**
 * An {@type "abstract expression"} represents any Blink expression. It is
 * parametric on the static {@type "type"} of the Blink expression.
 *
 * @type "abstract expression"
 * @supertype "object"
 * @field "expression type" "⊤'s type"
 *        The static {@type "type"} of the {@type "abstract expression"
 *        expression}.
 */
Public class "abstract expression" extends object
	with field
		expression type : ⊤'s type;

Alias "abstract statement" to $"abstract expression";

/**
 * Construct a {@type "abstract expression" Blink expression} {@type "type"} for
 * the specified {@type "type"}.
 *
 * @method "_expression"
 * @param "exprType" "⊤'s type"
 * @returns "abstract expression's type"
 */
Public method "_expression" is
[
	exprType : ⊤'s type
|
	extend abstract expression with expression type : (exprType's type)
];

/**
 * Strengthen the {@type "abstract expression" Blink expression} {@type "type"}
 * at compile time.
 *
 * @method "_expression"
 * @restricts "⊤'s type's type"
 */
Semantic restriction "_expression" is
[
	exprMeta : ⊤'s type's type
|
	(extend abstract expression with
		expression type : exprMeta)'s type
];

/**
 * Answer the {@type "abstract expression" subexpressions} of the specified
 * {@type "abstract expression" expression}.
 *
 * @method "_'s⁇subexpressions"
 * @param "expr" "abstract expression"
 * @returns "abstract expression*"
 */
Public abstract method "_'s⁇subexpressions" is
	[abstract expression]→abstract expression*;

/******************************************************************************
 *                                 Literals.                                  *
 ******************************************************************************/

/**
 * A {@type "literal"} denotes a statically known value. The {@field
 * "expression type"} of a {@type "literal"} must be an instance {@type
 * "any's type" type}.
 *
 * @type "literal"
 * @supertype "abstract expression"
 * @field "expression type" "any's type"
 */
Public explicit class "literal" extends abstract expression
	with field
		expression type : any's type;

/**
 * Answer the {@type "any" value} that the specified {@type "literal"} denotes.
 *
 * @method "_'s⁇value"
 * @param "lit" "literal"
 * @returns "any"
 */
Public method "_'s⁇value" is
[
	lit : literal
|
	lit's expression type's instance
];

/**
 * Strengthen the {@type "literal"}'s {@type "_'s⁇value" value} {@type "type"}
 * at compile time.
 *
 * @method "_'s⁇value"
 * @restricts "literal's type"
 */
Semantic restriction "_'s⁇value" is
[
	litType : literal's type
|
	litType's expression type's instance
];

/**
 * Construct a {@type "literal"} {@type "type"} for the specified {@type
 * "type"}.
 *
 * @method "_literal"
 * @param "valueType" "any's type"
 * @returns "literal's type"
 */
Public method "_literal" is
[
	valueType : any's type
|
	extend literal with expression type : (valueType's type)
];

/**
 * Strengthen the {@type "literal"} {@type "type"} at compile time.
 *
 * @method "_literal"
 * @restricts "any's type's type"
 */
Semantic restriction "_literal" is
[
	exprMeta : any's type's type
|
	(extend literal with expression type : exprMeta)'s type
];

Public method "_'s⁇subexpressions" is [lit : literal| <>];

/******************************************************************************
 *                                 Variables.                                 *
 ******************************************************************************/

/**
 * Answer an {@type "atom"} that denotes local scope.
 *
 * @method "local"
 * @returns "atom"
 */
Public "local" is a new atom;

/**
 * Answer an {@type "atom"} that denotes global scope.
 *
 * @method "global"
 * @returns "atom"
 */
Public "global" is a new atom;

/**
 * A {@type "scope"} denotes the scope of a {@type "variable"}, either {@method
 * "local"} or {@method "global"}.
 *
 * @type "scope"
 * @alias "{local, global}ᵀ"
 */
Public macro "scope" is [‘{local, global}ᵀ’];

"variable name" is a new field atom;
"variable scope" is a new field atom;

/**
 * A {@type "variable"} represents a statically typed fundamental storage unit
 * in a Blink program.
 *
 * @type "variable"
 * @supertype "abstract expression"
 * @param "variable name" "nonempty string"
 *        The lexical name of the {@type "variable"}.
 * @param "expression type" "any's type"
 * @param "variable scope" "scope"
 *        The {@type "scope"} of the {@type "variable"}, either {@method
 *        "local"} or {@type "global"}.
 */
Public class "variable" extends abstract expression
	with fields
		variable name : nonempty string ("_'s⁇name"),
		expression type : any's type,
		variable scope : scope ("_'s⁇scope");

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type} and {@type "scope"}.
 *
 * @method "__variable"
 * @param "varType" "any's type"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "__variable" is
[
	varType : any's type,
	scopeType : scope
|
	extend variable with
		expression type : (varType's type),
		variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "__variable"
 * @restricts "any's type's type"
 * @restricts "scope's type"
 */
Semantic restriction "__variable" is
[
	varMeta : any's type's type,
	scopeMeta : scope's type
|
	(extend variable with
		expression type : varMeta,
		variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "scope"}.
 *
 * @method "_variable"
 * @param "scopeType" "scope"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	scopeType : scope
|
	extend variable with variable scope : (scopeType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "scope's type"
 */
Semantic restriction "_variable" is
[
	scopeMeta : scope's type
|
	(extend variable with variable scope : scopeMeta)'s type
];

/**
 * Construct a {@type "variable"} {@type "type"} for the specified {@type
 * "any's type" type}.
 *
 * @method "_variable"
 * @param "varType" "any's type"
 * @returns "variable's type"
 */
Public method "_variable" is
[
	varType : any's type
|
	extend variable with expression type : (varType's type)
];

/**
 * Strengthen the {@type "variable"} {@type "type"} at compile time.
 *
 * @method "_variable"
 * @restricts "any's type's type"
 */
Semantic restriction "_variable" is
[
	varMeta : any's type's type
|
	(extend variable with expression type : varMeta)'s type
];

Public method "_'s⁇subexpressions" is [var : variable | <>];

