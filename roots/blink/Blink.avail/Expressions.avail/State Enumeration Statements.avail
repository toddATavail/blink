/*
 * State Enumeration Statements.avail
 * Copyright (c) Todd L Smith and Taylor DH Smith, 2017.
 * All rights reserved.
 */

Module "State Enumeration Statements"
Uses
	"Abstract Syntax Tree",
	"Avail"
Names
	/* State enumeration statements. */
	"(Blink)«_‡,and⁇»is|are a⁇public state|states.",

	/* Compiler support. */
	"\"state\"",
	"state type"
Body

/******************************************************************************
 *                       State enumeration statements.                        *
 ******************************************************************************/

/**
 * Answer the appropriate ordinal suffix for the specified {@type
 * "natural number"}.
 *
 * @method "ordinal suffix for_"
 * @param "n" "natural number"
 * @returns "nonempty string"
 */
Private method "ordinal suffix for_" is
[
	n : natural number
|
	if 4 ≤ n mod 100 ≤ 20 then ["th"]
	else [(<"th", "st", "nd", "rd"> ++ 6 of "th")[(n mod 10) + 1]]
];

/**
 * Declare the supported public states of this particular Blink program.
 *
 * @macro "(Blink)«_‡,and⁇»is|are a⁇public state|states."
 * @param "statesPhrase" "list phrase ⇒ (nonempty string literal+)"
 *        The declared state names.
 * @returns "sequence phrase"
 */
Public macro "(Blink)«_‡,and⁇»is|are a⁇public state|states." is
[
	statesPhrase : list phrase ⇒ (nonempty string literal+)
|
	exprs ::= statesPhrase's expressions;
	lastExpr ::= exprs' last;
	If ¬lastExpr ∈ literal phrase then
	[
		Reject parse, expected:
			format
				"public state names to be statically known (but the “①”‘②’ \
				\|name is not a literal)"
			with
				|exprs|,
				ordinal suffix for |exprs|
	];
],
[
	statesPhrase : list phrase ⇒ (nonempty string literal+)
|
	states ::= evaluate statesPhrase;
	/* Generate atoms and accessors for each of the states. */
	atomsAndAccessors ::= map each state of states through
		[
			stateName ::= state's value;
			stateAtom ::= new atom named stateName;
			lit ::= a literal with expression type ::= (stateAtom's type);
			<
				stateAtom,
				send $"Method_is_" with
				«<
					‘stateName’,
					«[<‘lit’>] : lit's type»
				>» : ⊤ → statement phrase
			>
		];
	accessorStmts ::= stripe atomsAndAccessors at 2;
	/* Generate the special "state" variable and give it a type which is the
	 * enumeration of the named states.
	 */
	stateTuple ::= stripe atomsAndAccessors at 1;
	stateSet ::= stateTuple→set;
	If |stateTuple| ≠ |stateSet| then
	[
		Reject parse, expected:
			"state names to be unique"
	];
	stateEnum ::= enumeration of stateSet;
	enumStmts ::=
	<
		/* Give this method an untypable name so that it doesn't pollute the
		 * Blink program's namespace.
		 */
		send $"Method_is_" with
		«<
			‘$"\"state\""’,
			«[<‘stateEnum’>] : stateEnum's type»
		>» : ⊤ → statement phrase
	>;
	stateVar ::= a variable with
		expression type ::= stateEnum,
		variable name ::= "state",
		variable scope ::= global,
		variable mutability ::= mutable;
	varStmts ::=
	<
		send $"Method_is_" with
		«<
			‘stateVar's name’,
			«[<‘stateVar’>] : stateVar's type»
		>» : ⊤ → statement phrase
	>;
	/* Generate and record a state enumeration statement. */
	stateEnumExpr ::= a state enumeration statement with
		declared states ::= stateTuple,
		expression type ::= ⊤;
	recordStmts ::= statement recorder for stateEnumExpr;
	stmts ::= accessorStmts ++ enumStmts ++ varStmts ++ recordStmts;
	seq «stmts»
];

/******************************************************************************
 *                             Compiler support.                              *
 ******************************************************************************/

/**
 * Answer the type of the generated standard state variable {@code "state"}.
 * This macro can only be invoked after a {@type "state enumeration statement"}
 * has been parsed, and should be used by the compiler to restrict the values
 * passed to generic macros that must work with the generated state type.
 *
 * @macro "state type"
 * @returns "send phrase ⇒ atom's type"
 */
Public macro "state type" is
[
	send $"\"state\"" with «<>» : atom's type
];
